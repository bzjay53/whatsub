# Whatsub 파일 구조 정리 및 최적화 계획

## 목차
1. [불필요한 파일 정리](#1-불필요한-파일-정리)
2. [네이밍 규칙](#2-네이밍-규칙)
3. [디렉토리 구조 최적화](#3-디렉토리-구조-최적화)
4. [단계별 작업 계획](#4-단계별-작업-계획)
5. [파일 관리 가이드라인](#5-파일-관리-가이드라인)

---

## 1. 불필요한 파일 정리

### 1.1 사용되지 않는 백업 파일

**식별 방법**:
- `.bak`, `.old`, `.backup` 확장자 파일 검색
- 파일명에 `backup`, `old`, `temp` 등의 키워드가 포함된 파일
- 동일 이름의 다른 버전 (`filename.v1.js`, `filename.js.20250101` 등)

**정리 방안**:
- 모든 백업 파일을 `archived` 디렉토리로 이동 후 압축 저장
- 3개월 이상 수정되지 않은 백업 파일 삭제
- Git 히스토리에 저장된 내용은 파일로 보관하지 않음

### 1.2 중복 기능의 파일

**식별 방법**:
- 코드 중복률 분석 도구 사용 (예: jscpd)
- 유사한 이름 및 기능을 가진 파일 목록화
- 임포트 및 사용 패턴 분석

**정리 방안**:
- 중복 기능 파일 통합 (기능별로 하나의 모듈로 리팩토링)
- 공통 함수를 유틸리티 모듈로 추출
- 중복 기능 사용 코드 참조 업데이트

### 1.3 폐기된 실험 코드

**식별 방법**:
- 주석 처리된 코드 블록 (50줄 이상)
- `TODO`, `EXPERIMENTAL`, `TO BE REMOVED` 등의 주석이 있는 코드
- 사용되지 않는 함수 및 변수 분석

**정리 방안**:
- 실험 목적 코드는 별도 브랜치로 이동
- 주석 처리된 대규모 코드 블록 제거
- 미사용 함수 및 변수 제거

### 1.4 임시 파일

**식별 방법**:
- `.tmp`, `.temp` 확장자 파일
- 로컬 개발 환경 설정 파일 (개인별 설정)
- 자동 생성된 로그 및 캐시 파일

**정리 방안**:
- 모든 임시 파일 삭제
- `.gitignore`에 임시 파일 패턴 추가
- 빌드/컴파일 결과물 정리 자동화 스크립트 구현

---

## 2. 네이밍 규칙

### 2.1 스크립트 파일 (기능별 접두사)

**기본 원칙**:
- 카멜케이스(camelCase) 사용
- 기능 또는 목적을 명확히 표현하는 이름 사용
- 약어 사용 최소화

**접두사 규칙**:
| 접두사 | 용도 | 예시 |
|--------|------|-------|
| `subtitle-` | 자막 처리 관련 | `subtitle-renderer.js`, `subtitle-parser.js` |
| `auth-` | 인증 관련 | `auth-google.js`, `auth-token.js` |
| `ui-` | 사용자 인터페이스 | `ui-popup.js`, `ui-settings.js` |
| `api-` | API 통신 | `api-client.js`, `api-endpoints.js` |
| `util-` | 유틸리티 함수 | `util-storage.js`, `util-formatting.js` |
| `background-` | 백그라운드 스크립트 | `background-main.js` |
| `content-` | 콘텐츠 스크립트 | `content-script.js`, `content-injector.js` |

### 2.2 스타일시트 파일

**기본 원칙**:
- 케밥케이스(kebab-case) 사용
- 컴포넌트 또는 기능 영역과 일치하는 이름 사용
- 모듈/컴포넌트 단위로 파일 분리

**네이밍 패턴**:
| 패턴 | 용도 | 예시 |
|------|------|-------|
| `component-*.css` | 컴포넌트별 스타일 | `subtitle-container.css`, `popup-header.css` |
| `layout-*.css` | 레이아웃 관련 스타일 | `layout-grid.css`, `layout-flex.css` |
| `theme-*.css` | 테마 관련 스타일 | `theme-dark.css`, `theme-light.css` |
| `variables.css` | CSS 변수 정의 | `variables.css` |
| `global.css` | 전역 스타일 | `global.css` |

### 2.3 이미지 및 미디어 파일

**기본 원칙**:
- 케밥케이스(kebab-case) 사용
- 목적과 크기 정보 포함
- 적절한 접두사 사용

**네이밍 패턴**:
| 패턴 | 용도 | 예시 |
|------|------|-------|
| `icon-*-[size].png` | 아이콘 | `icon-subtitle-16.png`, `icon-settings-32.png` |
| `logo-*-[size].png` | 로고 | `logo-whatsub-128.png`, `logo-full-256.png` |
| `bg-*.jpg` | 배경 이미지 | `bg-header.jpg`, `bg-settings.jpg` |
| `illustration-*.svg` | 일러스트레이션 | `illustration-welcome.svg` |

### 2.4 설정 파일

**기본 원칙**:
- 소문자와 하이픈 사용
- 명확한 목적 표시
- 표준 명명 규칙 준수

**네이밍 패턴**:
| 파일 유형 | 네이밍 규칙 | 예시 |
|----------|------------|-------|
| 설정 파일 | `config-[환경].json` | `config-dev.json`, `config-prod.json` |
| 매니페스트 | `manifest.json` | `manifest.json` |
| 환경 설정 | `.env.[환경]` | `.env.development`, `.env.production` |
| 빌드 설정 | `webpack.config.[환경].js` | `webpack.config.dev.js` |

---

## 3. 디렉토리 구조 최적화

### 3.1 현재 구조 분석

현재 디렉토리 구조는 다음과 같은 문제가 있습니다:
- 관련 파일들이 여러 디렉토리에 분산
- 명확한 역할 구분 없음
- 테스트 파일과 소스 파일이 혼재

### 3.2 최적화된 구조 제안

```
whatsub/
├── public/                      # 정적 파일
│   └── extension/               # 확장 프로그램 번들 디렉토리
│       ├── assets/              # 이미지, 폰트 등 자산 파일
│       │   ├── icons/           # 아이콘 파일
│       │   ├── images/          # 이미지 파일
│       │   └── fonts/           # 폰트 파일
│       ├── scripts/             # 핵심 스크립트 파일
│       │   ├── background/      # 백그라운드 스크립트
│       │   ├── content/         # 콘텐츠 스크립트
│       │   └── popup/           # 팝업 스크립트
│       ├── styles/              # 스타일시트 파일
│       │   ├── components/      # 컴포넌트별 스타일
│       │   ├── themes/          # 테마 스타일
│       │   └── global.css       # 전역 스타일
│       ├── vendor/              # 써드파티 라이브러리
│       └── manifest.json        # 확장 프로그램 매니페스트
├── src/                         # 소스 코드
│   ├── api/                     # API 통신 모듈
│   ├── components/              # UI 컴포넌트
│   │   ├── popup/               # 팝업 UI 컴포넌트
│   │   ├── options/             # 옵션 페이지 컴포넌트
│   │   └── subtitle/            # 자막 관련 컴포넌트
│   ├── services/                # 서비스 모듈
│   │   ├── auth/                # 인증 관련 서비스
│   │   ├── subtitle/            # 자막 처리 서비스
│   │   └── storage/             # 스토리지 서비스
│   ├── utils/                   # 유틸리티 함수
│   │   ├── dom/                 # DOM 조작 유틸리티
│   │   ├── format/              # 포맷팅 유틸리티
│   │   └── helpers/             # 기타 도우미 함수
│   └── config/                  # 설정 파일
├── tests/                       # 테스트 코드
│   ├── unit/                    # 단위 테스트
│   ├── integration/             # 통합 테스트
│   ├── e2e/                     # 엔드투엔드 테스트
│   └── mocks/                   # 테스트용 모의 객체
├── scripts/                     # 빌드 및 개발 스크립트
├── docs/                        # 문서
└── dist/                        # 빌드 결과물 (git에서 제외)
```

### 3.3 핵심 디렉토리 역할 및 가이드라인

#### 핵심 스크립트 폴더 (src/)
- 모든 소스 코드는 `src/` 디렉토리 내에 위치
- 기능별로 모듈화하여 서브디렉토리로 분리
- 모듈 간 의존성은 명시적으로 표현

#### UI 관련 파일 폴더 (src/components/)
- 모든 UI 컴포넌트는 `src/components/` 디렉토리에 위치
- 각 컴포넌트는 자체 디렉토리에 JS/CSS 파일 포함
- 공통 컴포넌트는 `src/components/common/`에 배치

#### 유틸리티 및 헬퍼 폴더 (src/utils/)
- 재사용 가능한 모든 함수는 `src/utils/` 디렉토리에 위치
- 함수 목적에 따라 서브디렉토리로 분류
- 각 유틸리티 파일은 단일 책임 원칙 준수

#### 설정 및 리소스 폴더 (src/config/, public/extension/assets/)
- 모든 설정 파일은 `src/config/` 디렉토리에 위치
- 환경별 설정 파일 분리
- 정적 리소스는 `public/extension/assets/` 디렉토리에 위치

#### 테스트 관련 폴더 (tests/)
- 모든 테스트 코드는 `tests/` 디렉토리에 위치
- 테스트 유형별로 서브디렉토리 분리
- 테스트 데이터 및 모의 객체는 `tests/mocks/`에 위치

---

## 4. 단계별 작업 계획

### 4.1 사전 작업

#### 사전 백업 방법
1. 현재 코드베이스 전체를 백업 브랜치로 저장
   ```bash
   git checkout -b backup/file-structure-before-refactor
   git push origin backup/file-structure-before-refactor
   ```
2. 주요 파일의 로컬 사본 생성
   ```bash
   mkdir -p ~/.backup/whatsub-$(date +%Y%m%d)
   cp -r ./public/extension ~/.backup/whatsub-$(date +%Y%m%d)/
   ```
3. 마일스톤별 스냅샷 지점 태그 생성
   ```bash
   git tag file-structure-refactor-start
   ```

#### 영향도 분석
1. 파일 간 의존성 맵 생성
2. 핵심 기능 식별 및 문서화
3. 리팩토링 위험 요소 평가

### 4.2 실행 계획

#### 1단계: 프로젝트 분석 및 준비 (1주)
- 모든 파일 인벤토리 목록 작성
- 사용되지 않는 파일 및 코드 식별
- 새 디렉토리 구조 상세 계획 수립

#### 2단계: 불필요한 파일 정리 (1주)
- 백업 파일 정리
- 중복 기능 파일 통합
- 폐기된 실험 코드 제거
- 임시 파일 정리

#### 3단계: 디렉토리 구조 생성 (1주)
- 새 디렉토리 구조 생성
- 기존 파일의 임시 복사본 생성
- 마이그레이션 계획 수립

#### 4단계: 파일 이동 및 리팩토링 (2주)
- 핵심 파일부터 순차적 이동
- 파일 간 의존성 업데이트
- 네이밍 규칙 적용
- 점진적 통합 및 테스트

#### 5단계: 검증 및 정리 (1주)
- 전체 빌드 및 테스트
- 문서 업데이트
- 사용하지 않는 파일 정리
- 최종 검토 및 승인

### 4.3 파일 이동/병합 순서

1. **핵심 모듈부터 이동**
   - 독립적인 유틸리티 함수
   - 확장 프로그램 핵심 구성요소 (백그라운드, 콘텐츠 스크립트)
   - API 및 서비스 모듈

2. **의존성이 있는 모듈 이동**
   - UI 컴포넌트
   - 비즈니스 로직
   - 이벤트 핸들러

3. **리소스 파일 정리**
   - 스타일시트
   - 이미지 및 미디어
   - 설정 파일

### 4.4 의존성 업데이트 방법

1. **임포트 경로 업데이트**
   - 상대 경로를 절대 경로로 변경
   - 경로 별칭(alias) 설정 (webpack, tsconfig)
   - 모듈 이름 표준화

2. **순환 의존성 해결**
   - 순환 의존성 식별
   - 중간 인터페이스 모듈 도입
   - 단방향 의존성 강제

3. **내부 API 표준화**
   - 모듈 간 인터페이스 명확화
   - 불필요한 노출 최소화
   - 내부 API 문서화

### 4.5 검증 및 테스트 방법

1. **단계별 검증**
   - 각 파일 이동 후 단위 테스트 실행
   - 관련 기능 수동 테스트
   - 빌드 및 번들링 확인

2. **통합 테스트**
   - 전체 확장 프로그램 기능 테스트
   - 크로스 브라우저 호환성 확인
   - 주요 사용 사례 시나리오 테스트

3. **성능 테스트**
   - 파일 구조 변경 전후 로딩 성능 비교
   - 메모리 사용량 비교
   - 번들 크기 분석

4. **회귀 테스트**
   - 자동화된 테스트 스위트 실행
   - 주요 기능 체크리스트 검증
   - 사용자 피드백 수집

---

## 5. 파일 관리 가이드라인

### 5.1 새 파일 추가 규칙

1. **위치 결정**
   - 파일의 주요 목적과 기능에 따라 적절한 디렉토리 선택
   - 기존 분류에 맞지 않는 경우 팀 논의 후 결정

2. **네이밍**
   - 섹션 2의 네이밍 규칙 준수
   - 기존 파일과 명확히 구분되는 이름 사용
   - 약어 사용 최소화

3. **문서화**
   - 파일 상단에 목적 및 기능 설명 주석 추가
   - 주요 함수 및 클래스에 JSDoc 주석 추가
   - README 또는 관련 문서 업데이트

4. **의존성**
   - 최소한의 필요 모듈만 임포트
   - 순환 의존성 방지
   - 외부 라이브러리 추가 시 팀 리뷰 필요

### 5.2 기존 파일 수정 규칙

1. **호환성 유지**
   - 공개 API 변경 시 버전 관리 준수
   - 기존 함수 시그니처 변경 최소화
   - 변경 시 영향 범위 문서화

2. **리팩토링 가이드라인**
   - 단일 책임 원칙 준수
   - 함수 및 클래스 크기 최소화
   - 코드 중복 방지

3. **코드 스타일**
   - 프로젝트 코드 스타일 가이드 준수
   - 일관된 들여쓰기 및 포맷팅
   - 주석은 "왜"에 초점

4. **테스트**
   - 모든 변경사항에 대한 테스트 코드 작성
   - 기존 테스트 케이스 유지 및 업데이트
   - 엣지 케이스 고려

### 5.3 파일 이동/제거 시 체크리스트

1. **이동 전 체크리스트**
   - 대상 파일의 모든 참조 식별
   - 의존성 그래프 업데이트 계획 수립
   - 관련 테스트 파일 식별

2. **이동 과정**
   - 파일 복사 후 참조 업데이트
   - 테스트 실행으로 검증
   - 기존 파일 제거

3. **제거 전 체크리스트**
   - 코드베이스 전체에서 참조 확인
   - 기능적 대체 확인
   - 제거 이유 문서화

4. **제거 후 검증**
   - 빌드 및 테스트 실행
   - 기능 정상 작동 확인
   - 문서 업데이트

### 5.4 정기적인 정리 일정

1. **일상적 관리**
   - 커밋 전 불필요한 코드 제거
   - 새 기능 개발 후 임시 파일 정리
   - 주석 처리된 코드 최소화

2. **스프린트 단위 정리**
   - 스프린트 종료 시 미사용 코드 식별 및 제거
   - 코드 중복 검사 및 리팩토링
   - 파일 구조 일관성 점검

3. **분기별 대규모 검토**
   - 프로젝트 전체 파일 구조 검토
   - 디렉토리 구조 최적화 검토
   - 코드 복잡도 및 기술 부채 평가

4. **연간 전체 정리**
   - 레거시 코드 마이그레이션 계획
   - 파일 구조 현대화
   - 전체 문서 업데이트

---

## 6. 구현 도구 및 자동화

### 6.1 분석 도구

- **depcheck**: 사용되지 않는 의존성 분석
- **madge**: 모듈 의존성 그래프 생성
- **jscpd**: 코드 중복 탐지
- **eslint**: 미사용 코드 및 임포트 감지

### 6.2 리팩토링 도구

- **jscodeshift**: 대규모 코드 변환 자동화
- **prettier**: 코드 포맷팅 표준화
- **import-sort**: 임포트 문 정렬 및 그룹화
- **npm-check-updates**: 의존성 업데이트 관리

### 6.3 자동화 스크립트

- 미사용 파일 감지 스크립트
- 파일 이동 및 참조 업데이트 스크립트
- 정기적 코드 정리 스크립트
- 구조 검증 스크립트

---

마지막 업데이트: 2025-04-15  
버전: 1.0.0 